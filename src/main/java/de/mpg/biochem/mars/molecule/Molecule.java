/*******************************************************************************
 * Copyright (C) 2019, Karl Duderstadt
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package de.mpg.biochem.mars.molecule;

import de.mpg.biochem.mars.table.*;
import de.mpg.biochem.mars.kcp.*;

import java.util.Iterator;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;

import java.util.Objects;
import java.util.Set;

import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;


/**
 * Molecule records act as the storage location for an array of molecule properties. Molecule 
 * records are stored in {@link MoleculeArchive}s to allow for fast and efficient retrieval 
 * and optimal organization. 
 * <p>
 * Molecule records are designed to allow for storage of many different kinds
 * of single-molecule time-series data. They contain a primary {@link MARSResultsTable} 
 * (or DataTable) with molecule properties typically as a function of time/slice of a video. 
 * This may include position or intensity information. To facilitate efficient and reproducible 
 * processing Molecule records may also contain calculated parameters, tags, notes, and 
 * kinetic change point segment {@link MARSResultsTable}s generated by {@link KCPCommand}. 
 * Molecule records are assigned a random UID string at the time of creation derived from 
 * a base58 encoded UUID for readability. This serves as their primary identifier within 
 * {@link MoleculeArchive}s and for a range of transformations and merging operations. 
 * Molecule records also have a UID string for corresponding {@link MARSImageMetaData} records, 
 * which contain information about the imaging settings, the timing of frames etc.. 
 * during data collection. 
 * </p>
 * <p>
 * Molecule records can be saved to JSON for storage when done processing. They are then either 
 * stored as an array within MoleculeArchive .yama files or as individual json files within 
 * .yama.store directories.
 * </p>
 * @author Karl Duderstadt
 */

public class Molecule {
	//Unique ID used for Chronicle map storage and universal identification.
	private String UID;
	
	//Reference to MoleculeArchive containing the molecule
	private	MoleculeArchive parent;
	
	//UID of ImageMetaData associated wit this molecule.
	private String imageMetaDataUID;
	
	//For any notes to be made about the molecule
	private String Notes;
	
	//tags added for filtering...
	private LinkedHashSet<String> Tags;
	
	//Hashmap that maps string parameters to doubles
	private LinkedHashMap<String, Double> Parameters;
	
	//DataTable with raw data and converted data etc.. 
	private MARSResultsTable datatable;
	
	//Segments tables resulting from change point fitting
	//ArrayList has two items:
	//XColumn is at index 0
	//YColumn is at index 1
	private LinkedHashMap<ArrayList<String>, MARSResultsTable> segmentTables;
	
	/**
	 * Constructor for loading a Molecule record from a file. Typically,
	 * used when streaming records into memory when loading a {@link MoleculeArchive}
	 * or when a record is retrieved from the virtual store. 
	 * 
	 * @param jParser A JsonParser at the start of the molecule record json
	 * for loading the molecule record from a file.
	 */
	public Molecule(JsonParser jParser) {
		datatable = new MARSResultsTable();
		initializeVariables();
		try {
			fromJSON(jParser);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**
	 * Constructor for creating an empty Molecule record with the
	 * specified UID. 
	 * 
	 * @param UID The unique identifier for this Molecule record.
	 */
	public Molecule(String UID) {
		this.UID = UID;
		datatable = new MARSResultsTable();
		initializeVariables();
	}

	/**
	 * Constructor for creating a new Molecule record with the
	 * specified UID and the {@link MARSResultsTable} given
	 * as the DataTable. 
	 * 
	 * @param UID The unique identifier for this Molecule record.
	 * @param datatable The {@link MARSResultsTable} to use for 
	 * initialization.
	 */
	public Molecule(String UID, MARSResultsTable datatable) {
		this.UID = UID;
		this.datatable = datatable;
		initializeVariables();
	}
	
	private void initializeVariables() {
		segmentTables = new LinkedHashMap<>();
		Parameters = new LinkedHashMap<>();
		Tags = new LinkedHashSet<String>();
	}
	
	/**
	 * Write the molecule record to JSON. Uses the provided
	 * JsonGenerator created elsewhere to stream the molecule 
	 * record to file.
	 * 
	 * @param jGenerator A JsonGenerator for stream the molecule
	 * record to a file.
	 * 
	 * @throws IOException if there is a problem writing to the file.
	 */
	public void toJSON(JsonGenerator jGenerator) throws IOException {
		jGenerator.writeStartObject();
		
		//write out UID - all molecules must have this field.
		jGenerator.writeStringField("UID", UID);
		
		if (imageMetaDataUID != null)
			jGenerator.writeStringField("ImageMetaDataUID", imageMetaDataUID);
		
		//Write out notes if there are any
		if (Notes != null)
			jGenerator.writeStringField("Notes", Notes);
		
		//Write out arrays of tags if tags have been added.
		if (Tags.size() > 0) {
			jGenerator.writeFieldName("Tags");
			jGenerator.writeStartArray();
			Iterator<String> iterator = Tags.iterator();
			while(iterator.hasNext())
				jGenerator.writeString(iterator.next());
			jGenerator.writeEndArray();
		}
		
		//Write out parameters, which are number fields used to filter and process the molecule..
		if (Parameters.size() > 0) {
			jGenerator.writeObjectFieldStart("Parameters");
			for (String name:Parameters.keySet())
				jGenerator.writeNumberField(name, Parameters.get(name));
			jGenerator.writeEndObject();
		}
 		
		//Write out data table (will do nothing if there are no columns
		if (datatable.getColumnCount() > 0) {
			jGenerator.writeFieldName("DataTable");
			datatable.toJSON(jGenerator);
		}
		
		//Write out segment tables generated from KCP as object that have two fields that store the x column and y column names used during KCP
		if (segmentTables.size() > 0) {
			jGenerator.writeArrayFieldStart("SegmentTables");
			for (ArrayList<String> tableColumnNames :segmentTables.keySet()) {
				if (segmentTables.get(tableColumnNames).size() > 0) {
					jGenerator.writeStartObject();
					
					jGenerator.writeStringField("xColumnName", tableColumnNames.get(0));
					jGenerator.writeStringField("yColumnName", tableColumnNames.get(1));
					
					jGenerator.writeFieldName("Table");
					segmentTables.get(tableColumnNames).toJSON(jGenerator);
					
					jGenerator.writeEndObject();
				}
			}
			jGenerator.writeEndArray();
		}
		jGenerator.writeEndObject();
	}
	
	/**
	 * Read a molecule record from JSON. Load a molecule record
	 * from a file using the JsonParser stream provided.
	 * 
	 * @param jParser A JsonParser for loading the molecule
	 * record from a file.
	 * 
     * @throws IOException if there is a problem reading from the file.
	 */
	public void fromJSON(JsonParser jParser) throws IOException {
		//We assume a molecule object and just been detected and now we want to parse all the values into this molecule entry.
		while (jParser.nextToken() != JsonToken.END_OBJECT) {
		    String fieldname = jParser.getCurrentName();

		    if (fieldname == null)
		    	continue;
		    
		    if ("UID".equals(fieldname)) {
		    	jParser.nextToken();
		        UID = jParser.getText();
		        continue;
		    }
		    
		    if ("ImageMetaDataUID".equals(fieldname)) {
		    	jParser.nextToken();
		    	imageMetaDataUID = jParser.getText();
		    	continue;
		    }
		    
		    if ("Notes".equals(fieldname)) {
		    	jParser.nextToken();
		        Notes = jParser.getText();
		        continue;
		    }
		    
		    if("Tags".equals(fieldname)) {
		    	//First we move past object start ?
		    	jParser.nextToken();
		    	
		    	while (jParser.nextToken() != JsonToken.END_ARRAY) {
		            Tags.add(jParser.getText());
		        }
		    	continue;
		    }
			    
		    if("Parameters".equals(fieldname)) {
		    	//First we move past object start ?
		    	jParser.nextToken();
		    	
		    	//Then we move through fields
		    	while (jParser.nextToken() != JsonToken.END_OBJECT) {
		    		String subfieldname = jParser.getCurrentName();
		    		jParser.nextToken();
		    		if (jParser.getCurrentToken().equals(JsonToken.VALUE_STRING)) {
	    				String str = jParser.getValueAsString();
	    				if (Objects.equals(str, new String("Infinity"))) {
	    					Parameters.put(subfieldname, Double.POSITIVE_INFINITY);
	    				} else if (Objects.equals(str, new String("-Infinity"))) {
	    					Parameters.put(subfieldname, Double.NEGATIVE_INFINITY);
	    				} else if (Objects.equals(str, new String("NaN"))) {
	    					Parameters.put(subfieldname, Double.NaN);
	    				}
	    			} else {
	    				Parameters.put(subfieldname, jParser.getDoubleValue());
	    			}
		    	}
		    	continue;
		    }
		    
		    if("DataTable".equals(fieldname)) {
			    datatable.fromJSON(jParser);
			    continue;
		    }
		    
		    if("SegmentTables".equals(fieldname)) {
		    	jParser.nextToken();
		    	while (jParser.nextToken() != JsonToken.END_ARRAY) {
			    	while (jParser.nextToken() != JsonToken.END_OBJECT) {
			    		String xColumnName = "";
			    		String yColumnName = "";
			    	
			    		//Needed for backwards compatibility when reverse order was used...
					    if ("xColumnName".equals(jParser.getCurrentName())) {
					    	jParser.nextToken();
					    	xColumnName = jParser.getText();
					    	
					    	//Then move past the field and next name
						    jParser.nextToken();
						    jParser.nextToken();
					    	yColumnName = jParser.getText();
					    } else if ("yColumnName".equals(jParser.getCurrentName())) {
					    	jParser.nextToken();
					    	yColumnName = jParser.getText();
					    	
					    	//Then move past the field and next name
						    jParser.nextToken();
						    jParser.nextToken();
					    	xColumnName = jParser.getText();
					    }
					    
					    ArrayList<String> tableColumnNames = new ArrayList<String>();

				    	tableColumnNames.add(xColumnName);
				    	tableColumnNames.add(yColumnName);
				    	
				    	MARSResultsTable segmenttable = new MARSResultsTable(tableColumnNames.get(0), tableColumnNames.get(1));
				    	
				    	//Move past Table
				    	jParser.nextToken();
				    	
				    	segmenttable.fromJSON(jParser);
				    	
				    	segmentTables.put(tableColumnNames, segmenttable);
			    	}
		    	}
		    	continue;
		    }
		    
		    //SHOULD BE UNREACHABLE
		    //This is only reached if there is an unexpected field added to the json record
		    //In that case we simply pass through it
		    //This ensure if extra fields are added in the future
		    //old versions will be able to open the new files
		    //However, the missing fields will not be saved properly
		    //In the case of a virtual archive new fields will be systematically removed as records are opened and saved...
		    if (jParser.getCurrentToken() == JsonToken.START_OBJECT) {
		    	System.out.println("unknown object encountered in molecule record ... skipping");
		    	passThroughUnknownObjects(jParser);
		    }
		}
	}
	
	private void passThroughUnknownObjects(JsonParser jParser) throws IOException {
    	while (jParser.nextToken() != JsonToken.END_OBJECT) {
    		if (jParser.getCurrentToken() == JsonToken.START_OBJECT)
    			passThroughUnknownObjects(jParser);
    	}
	}
	
	/**
	 * Generate a JSON String representation of the molecule record.
	 * 
	 * @return Return a JSON string representation of the molecule.
	 */
	public String toJSONString() {
		ByteArrayOutputStream stream = new ByteArrayOutputStream();

		JsonFactory jfactory = new JsonFactory();
		JsonGenerator jGenerator;
		try {
			jGenerator = jfactory.createGenerator(stream, JsonEncoding.UTF8);
			toJSON(jGenerator);
			jGenerator.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return stream.toString();
	}
	
	/**
	 * Get the UID for this molecule record.
	 * 
	 * @return Returns the UID.
	 */
	public String getUID() {
		return UID;
	}
	
	/**
	 * Set the UID of the {@link MARSImageMetaData} record associated with
	 * this molecule. The {@link MARSImageMetaData} contains information about
	 * the data collection (Timing of frames, colors, collection date, etc...)
	 * 
	 * @param imageMetaDataUID The new ImageMetaData UID to set.
	 */
	public void setImageMetaDataUID(String imageMetaDataUID) {
		this.imageMetaDataUID = imageMetaDataUID;
	}
	
	/**
	 * Get the UID of the {@link MARSImageMetaData} record associated with
	 * this molecule. The {@link MARSImageMetaData} contains information about
	 * the data collection (Timing of frames, colors, collection date, etc...)
	 * 
	 * @return Return a JSON string representation of the molecule.
	 */
	public String getImageMetaDataUID() {
		return imageMetaDataUID;
	}

	/**
	 * Get notes for this record. Notes can be added during manual sorting
	 * to point out a feature or important detail about the current record.
	 * 
	 * @return Returns a string containing any notes associated with this molecule record.
	 */
	public String getNotes() {
		return Notes;
	}
	
	/**
	 * Sets the notes for this record. Notes can be added during manual sorting
	 * to point out a feature or important detail about the current record.
	 * 
	 * @param Notes Any notes about this molecule.
	 */
	public void setNotes(String Notes) {
		this.Notes = Notes;
	}
	
	/**
	 * Add to any notes already in the record.
	 *  
	 * @param Note String with the note to add to the molecule record.
	 */
	public void addNote(String Note) {
		Notes += Note;
	}
	
	/**
	 * Add a string tag to the record. Tags are used for marking individual
	 * record to sorting and processing with subsets of molecules.
	 *  
	 * @param tag The string tag to be added.
	 */
	public void addTag(String tag) {
		Tags.add(tag);
		if (parent != null) {
			parent.getProperties().addTag(tag);
		}
	}
	
	/**
	 * Check if the molecule record has a tag.
	 *  
	 * @param tag The string tag to check for.
	 * @return Returns true if the molecule has the tag
	 * and false if the molecule doesn't.
	 */
	public boolean hasTag(String tag) {
		return Tags.contains(tag);
	}
	
	/**
	 * Check if the molecule has to tags.
	 *  
	 * @return Returns true if the molecule has no tags.
	 */
	public boolean hasNoTags() {
		return Tags.size() == 0;
	}
	
	/**
	 * Get the set of all tags.
	 *  
	 * @return Returns the set of tags for this molecule record.
	 */
	public LinkedHashSet<String> getTags() {
		return Tags;
	}
	
	/**
	 * Remove a string tag from the record.
	 *  
	 * @param tag The string tag to remove.
	 */
	public void removeTag(String tag) {
		Tags.remove(tag);
	}
	
	/**
	 * Remove all tags from the molecule record.
	 */
	public void removeAllTags() {
		Tags.clear();
	}
	
	/**
	 * Add or update a parameter value. Parameters are used to store single 
	 * values associated with the molecule. For example, this can be the 
	 * start and stop times for a region of interest. Or calculated features
	 * such as the slope or MSD. Storing parameters with the molecule data
	 * allows for easier and more efficient processing and data extraction.
	 *  
	 * @param parameter The string parameter name.
	 * @param value The double value to set for the parameter name.
	 */
	public void setParameter(String parameter, double value) {
		Parameters.put(parameter, value);
		if (parent != null) {
			parent.getProperties().addParameter(parameter);
		}
	}
	
	/**
	 * Remove all parameter values from the molecule record.
	 */
	public void removeAllParameters() {
		Parameters.clear();
	}
	
	/**
	 * Remove parameter. Removes the name and value pair.
	 * 
	 * @param parameter The parameter name to remove.
	 */
	public void removeParameter(String parameter) {
		if (Parameters.containsKey(parameter)) {
			Parameters.remove(parameter);
		}
	}
	
	/**
	 * Get the value of a parameter.
	 * 
	 * @param parameter The string parameter name to retrieve the value for.
	 * @return Returns the double value for the parameter name given.
	 */
	public double getParameter(String parameter) {
		if (Parameters.containsKey(parameter)) {
			return Parameters.get(parameter);
		} else {
			return Double.NaN;
		}
	}
	
	/**
	 * Get the value of a parameter.
	 * 
	 * @param parameter The string parameter name to retrieve the value for.
	 * @return Returns the double value for the parameter name given.
	 */
	public boolean hasParameter(String parameter) {
		return Parameters.containsKey(parameter);
	}
	
	/**
	 * Get the map for all parameters.
	 * 
	 * @return Returns the map of parameter names to values.
	 */
	public LinkedHashMap<String, Double> getParameters() {
		return Parameters;
	}
		
	/**
	 * Add or update a Segments table ({@link MARSResultsTable}) generated 
	 * using the yColumnName and xColumnName. The {@link KCPCommand} performs
	 * kinetic change point analysis generating segments to fit regions
	 * of a trace. The information about these segments is added using
	 * this method.
	 * 
	 * @param xColumnName The name of the column used for x for KCP analysis.
	 * @param yColumnName The name of the column used for y for KCP analysis.
	 * @param segs The {@link MARSResultsTable} to add that contains the 
	 * segments.
	 */
	public void putSegmentsTable(String xColumnName, String yColumnName, MARSResultsTable segs) {
		ArrayList<String> tableColumnNames = new ArrayList<String>();
		tableColumnNames.add(xColumnName);
		tableColumnNames.add(yColumnName);
		
		//Let's also make sure the MARSResultsTable contains
		//the x and y column names...
		//Should always be set but just in case....
		segs.setXYColumnNames(xColumnName, yColumnName);
		segmentTables.put(tableColumnNames, segs);
	}
	
	/**
	 * Retrieve a Segments table ({@link MARSResultsTable}) generated 
	 * using xColumnName and yColumnName.
	 * 
	 * @param xColumnName The name of the x column used for analysis.
	 * @param yColumnName The name of the y column used for analysis.
	 * @return The MARSResultsTable generated using the columns specified.
	 */	
	public MARSResultsTable getSegmentsTable(String xColumnName, String yColumnName) {
		ArrayList<String> tableColumnNames = new ArrayList<String>();
		tableColumnNames.add(xColumnName);
		tableColumnNames.add(yColumnName);
		return segmentTables.get(tableColumnNames);
	}
	
	/**
	 * Check if record has a Segments table ({@link MARSResultsTable}) generated 
	 * using xColumnName and yColumnName.
	 * 
	 * @param xColumnName The name of the x column used for analysis.
	 * @param yColumnName The name of the y column used for analysis.
	 * @return Boolean whether the segment table exists.
	 */	
	public boolean hasSegmentsTable(String xColumnName, String yColumnName) {
		ArrayList<String> tableColumnNames = new ArrayList<String>();
		tableColumnNames.add(xColumnName);
		tableColumnNames.add(yColumnName);
		return segmentTables.containsKey(tableColumnNames);
	}
	
	/**
	 * Retrieve a Segments table ({@link MARSResultsTable}) generated 
	 * using yColumnName and xColumnName provided in index positions 0
	 * and 1 of an ArrayList, respectively.
	 * 
	 * @param tableColumnNames The xColumnName and yColumnName used when
	 * generating the table, provided in index positions 0 and 1 of an 
	 * ArrayList, respectively.
	 * @return The MARSResultsTable generated using the columns specified.
	 */	
	public MARSResultsTable getSegmentsTable(ArrayList<String> tableColumnNames) {
		return segmentTables.get(tableColumnNames);
	}
	
	/**
	 * Remove the Segments table ({@link MARSResultsTable}) generated 
	 * using yColumnName and xColumnName.
	 * 
	 * @param xColumnName The name of the x column used for analysis.
	 * @param yColumnName The name of the y column used for analysis.
	 */
	public void removeSegmentsTable(String xColumnName, String yColumnName) {
		ArrayList<String> tableColumnNames = new ArrayList<String>();
		tableColumnNames.add(xColumnName);
		tableColumnNames.add(yColumnName);
		segmentTables.remove(tableColumnNames);
	}
	
	/**
	 * Retrieve a Segments table ({@link MARSResultsTable}) generated 
	 * using yColumnName and xColumnName.
	 * 
	 * @return The Set of ArrayLists holding the x and y column names at
	 * index positions 0 and 1, respectively.
	 */
	public Set<ArrayList<String>> getSegmentTableNames() {
		return segmentTables.keySet();
	}

	/**
	 * Get the {@link MARSResultsTable} DataTable holding the primary data for
	 * this molecule record.
	 * 
	 * @return The primary DataTable for this molecule record.
	 */
	public MARSResultsTable getDataTable() {
		return datatable;
	}
	
	/**
	 * Set the {@link MARSResultsTable} holding the primary data for
	 * this molecule record. Usually this is tracking or intensity 
	 * as a function of time.
	 * 
	 * @param table The {@link MARSResultsTable} to add or update in the 
	 * molecule record.
	 */
	public void setDataTable(MARSResultsTable table) {
		//This means we are resetting all the data...
		datatable.clear();
		
		//Now set to new table
		datatable = table;
	}
	
	/**
	 * Set the parent {@link MoleculeArchive} that this molecule
	 * record is stored in.
	 * 
	 * @param archive The {@link MoleculeArchive} holding this record.
	 */
	public void setParent(MoleculeArchive archive) {
		parent = archive;
	}
}
